#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
			
#define FALSE							 0
#define TRUE							 1
														
#define BITMAPCOREHEADER_SIZE            12              
#define BITMAPCOREHEADER_COLOR_PLANES    1
#define BITMAP_MAGIC_NUMBER              0x4D42
#define BITMAP_FILE_HEADER_SIZE          14
#define COLOR_TABLE_ENTRY_SIZE           3       // Color table is RGB24 in BITMAPCOREHEADER

#define BITMAP_FILE_HEADER_RESERVED1     (('I'<<8) + 'K')  // We'll use 'KITS' to identify our bitmaps
#define BITMAP_FILE_HEADER_RESERVED2     (('S'<<8) + 'T')

#pragma pack(push, 1)
struct FILE_HEADER {
	uint16_t magic;  	// We'll go with the 'BM' magic number 0x42 0x4D (Windows BMP)
	uint32_t size;      // Size of file in bytes 
	uint16_t reserved1;
	uint16_t reserved2;
	uint32_t start;     // Starting address of pixel array
};

// This is the DIB_HEADER for a BITMAPCOREHEADER (original format)
struct DIB_HEADER {
	uint32_t header_size;  // Size of this header, always 12 bytes... (why is this a 32 bit number)
	uint16_t width; 	   // Width of image
	uint16_t height;       // Height of image
	uint16_t color_planes; // Must be 1
	uint16_t bpp;          // Bits per pixel
};

struct COLOR_TABLE_ENTRY {
	uint8_t r;
	uint8_t g;
	uint8_t b;
};

#pragma pack(pop)



struct BITMAP {
	struct FILE_HEADER        *file_header;
	struct DIB_HEADER         *dib_header;
	// Array of color table entries, length is determined by bpp
	struct COLOR_TABLE_ENTRY **color_table;  
	
	uint8_t row_width;   // Number of bytes in a row
	uint8_t *pixelarray; // Already padded!
};

int write_bitmap_to_file(struct BITMAP *bitmap, char *filename);
struct BITMAP *create_bitmap(uint16_t width, uint16_t height, uint16_t bpp);
void free_bitmap(struct BITMAP *bitmap);

// My 8x8 font I designed, 96 characters, each character is a vertical column below
uint8_t font[] = {  0x00,0x18,0x66,0x24,0x10,0x60,0x30,0x18,0x08,0x10,0x10,0x00,0x00,0x00,0x00,0x02,0x18,0x18,0x3C,0x7E,0x28,0x7E,0x3C,0x7E,0x3C,0x3C,0x00,0x00,0x04,0x00,0x20,0x3C,0x7C,0x18,0x7C,0x3C,0x78,0x7E,0x7E,0x3C,0x42,0x3E,0x7E,0x42,0x40,0x42,0x42,0x3C,0x7C,0x3C,0x7C,0x3E,0x7E,0x42,0x42,0x42,0x42,0x82,0x7E,0x38,0x80,0x38,0x18,0x00,0x60,0x00,0x40,0x00,0x02,0x00,0x1C,0x00,0x40,0x00,0x00,0x40,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x08,0x18,0x00,0x00,
					0x00,0x18,0x66,0x24,0x3C,0x64,0x48,0x18,0x10,0x08,0x7C,0x10,0x00,0x00,0x00,0x04,0x66,0x78,0x42,0x02,0x28,0x40,0x40,0x02,0x42,0x42,0x18,0x18,0x08,0x00,0x10,0x42,0x82,0x24,0x42,0x42,0x44,0x40,0x40,0x40,0x42,0x08,0x04,0x44,0x40,0x66,0x62,0x42,0x42,0x42,0x42,0x40,0x08,0x42,0x42,0x42,0x42,0x44,0x02,0x20,0x40,0x08,0x24,0x00,0x18,0x00,0x40,0x00,0x02,0x00,0x22,0x00,0x40,0x08,0x08,0x40,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x08,0x04,0x00,0x00,
					0x00,0x18,0x00,0x7E,0x50,0x08,0x30,0x00,0x20,0x04,0x28,0x10,0x00,0x00,0x00,0x08,0x42,0x08,0x02,0x0C,0x48,0x7C,0x40,0x04,0x42,0x42,0x18,0x18,0x10,0x7E,0x08,0x04,0xBA,0x42,0x42,0x40,0x42,0x40,0x40,0x40,0x42,0x08,0x04,0x48,0x40,0x5A,0x52,0x42,0x42,0x42,0x42,0x40,0x08,0x42,0x24,0x42,0x24,0x28,0x04,0x20,0x20,0x08,0x42,0x00,0x00,0x3C,0x5c,0x3E,0x3A,0x3C,0x78,0x3C,0x5C,0x00,0x00,0x44,0x08,0x2C,0x5C,0x3C,0x3C,0x3C,0x5C,0x3E,0x3E,0x42,0x42,0x42,0x42,0x42,0x7E,0x20,0x08,0x04,0x00,0x00,
					0x00,0x18,0x00,0x24,0x38,0x10,0x52,0x00,0x20,0x04,0x44,0x7C,0x00,0x7C,0x00,0x10,0x4A,0x08,0x0C,0x1C,0x7E,0x02,0x7C,0x08,0x3C,0x3E,0x00,0x00,0x20,0x00,0x04,0x08,0xAE,0x7E,0x7C,0x40,0x42,0x70,0x70,0x4E,0x7E,0x08,0x04,0x70,0x40,0x5A,0x5A,0x42,0x7C,0x4A,0x7C,0x3C,0x08,0x42,0x24,0x5A,0x18,0x10,0x18,0x20,0x10,0x08,0x00,0x00,0x00,0x02,0x62,0x40,0x46,0x42,0x20,0x42,0x62,0x08,0x18,0x48,0x08,0x52,0x62,0x42,0x42,0x42,0x62,0x40,0x08,0x42,0x42,0x52,0x24,0x42,0x04,0x40,0x08,0x02,0x32,0x00,
					0x00,0x18,0x00,0x7E,0x14,0x20,0x8C,0x00,0x20,0x04,0x00,0x10,0x00,0x00,0x00,0x20,0x42,0x08,0x10,0x02,0x08,0x02,0x42,0x10,0x42,0x02,0x18,0x18,0x10,0x7E,0x08,0x08,0xB6,0x42,0x42,0x40,0x42,0x40,0x40,0x42,0x42,0x08,0x04,0x48,0x40,0x42,0x4A,0x42,0x40,0x4A,0x44,0x02,0x08,0x42,0x24,0x5A,0x24,0x10,0x20,0x20,0x08,0x08,0x00,0x00,0x00,0x3E,0x62,0x40,0x46,0x7C,0x20,0x42,0x42,0x08,0x08,0x70,0x08,0x52,0x42,0x42,0x42,0x42,0x40,0x3C,0x08,0x42,0x24,0x52,0x18,0x42,0x18,0x20,0x08,0x04,0x4C,0x00,
					0x00,0x00,0x00,0x24,0x78,0x46,0x98,0x00,0x10,0x08,0x00,0x10,0x30,0x00,0x30,0x40,0x66,0x08,0x20,0x02,0x08,0x02,0x42,0x10,0x42,0x04,0x18,0x18,0x08,0x00,0x10,0x00,0x82,0x42,0x42,0x42,0x44,0x40,0x40,0x42,0x42,0x08,0x0C,0x44,0x40,0x42,0x46,0x42,0x40,0x44,0x42,0x02,0x08,0x66,0x18,0x66,0x42,0x10,0x40,0x20,0x04,0x08,0x00,0x00,0x00,0x46,0x62,0x40,0x46,0x40,0x20,0x3E,0x42,0x08,0x08,0x48,0x08,0x52,0x42,0x42,0x7C,0x3E,0x40,0x02,0x08,0x46,0x24,0x52,0x24,0x3E,0x20,0x20,0x08,0x04,0x00,0x00,
					0x00,0x18,0x00,0x24,0x10,0x06,0x64,0x00,0x08,0x10,0x00,0x00,0x60,0x00,0x30,0x80,0x18,0x7E,0x7E,0x7C,0x08,0x7C,0x3C,0x10,0x3C,0x38,0x00,0x30,0x04,0x00,0x20,0x08,0x7C,0x42,0x7C,0x3C,0x78,0x7E,0x40,0x3C,0x42,0x3E,0x78,0x42,0x7E,0x42,0x42,0x3C,0x40,0x3A,0x42,0x7C,0x08,0x3A,0x18,0x24,0x42,0x10,0x7E,0x38,0x02,0x38,0x00,0xFE,0x00,0x3A,0x5C,0x3E,0x3A,0x3E,0x20,0x02,0x42,0x08,0x48,0x44,0x08,0x52,0x42,0x3C,0x40,0x02,0x40,0x7C,0x08,0x3A,0x18,0x2C,0x42,0x02,0x7E,0x18,0x08,0x18,0x00,0x00,
					0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00 };


int main(int argc, char **argv)
{
	int x = 0; int y = 0; int z = 0;
	struct BITMAP *test = NULL;
	
	
	test = create_bitmap(128, 48, 1);
	
	test->color_table[1]->r = 255;
	test->color_table[1]->g = 255;
	test->color_table[1]->b = 255;
	
	// Test everything out by writing my font out to the bitmap image
	// In 6 rows of 16 columns
	for(z = 0; z < 48; z+=8) // Cycle through the 6 rows
		for(y = 0; y < 8; y++) // 8 lines per character
			for (x = 0; x < 16; x++) // 16 characters per row (1bpp)
				*(test->pixelarray + x + (test->row_width * (47 - (y + z)))) = font[(y * 96) + x + (z*2)];
			
	write_bitmap_to_file(test, "test.bmp");
	
	
	free_bitmap(test);
	
	return TRUE;
}

/* write_bitmap_to_file(bitmap, filename)
 ** Writes the specified bitmap structure to the file "filename"
 ****************************************************************/
int write_bitmap_to_file(struct BITMAP *bitmap, char *filename)
{
	FILE *outfile = NULL;
	int i = 0;
	
	// Try and open the file for binary writing
	outfile = fopen(filename, "wb");
	
	if(!outfile)
	{
		// Failed to open file
		return FALSE;
	}
	
	// These are assuming the structure is packed, and little-endian!
	fwrite(bitmap->file_header, sizeof(struct FILE_HEADER), 1, outfile);
	fwrite(bitmap->dib_header,  sizeof(struct  DIB_HEADER), 1, outfile);
	
	for(i = 0; i < (1 << bitmap->dib_header->bpp); i++)
	{
		fwrite(bitmap->color_table[i], sizeof(struct COLOR_TABLE_ENTRY), 1, outfile);
	}
	
	fwrite(bitmap->pixelarray, bitmap->row_width, bitmap->dib_header->height, outfile);
	
	fclose(outfile);
	
	return TRUE;
}


/* create_bitmap(width, height, bpp)
 ** Creates and initializes a bitmap of width by heigth at bpp, 
 ** with a blank pixel array and color table.
 ****************************************************************/
struct BITMAP *create_bitmap(uint16_t width, uint16_t height, uint16_t bpp)
{
	struct BITMAP *bitmap             = NULL;
	struct FILE_HEADER *fheader       = NULL;
	struct DIB_HEADER  *dheader       = NULL;
	struct COLOR_TABLE_ENTRY **ctable = NULL;
	int i = 0; int header_size = 0; uint16_t row_size;
	
	// Try and allocate space in memory for the bitmap headers
	bitmap  = malloc(sizeof(struct BITMAP));
	fheader = malloc(sizeof(struct FILE_HEADER));
	dheader = malloc(sizeof(struct DIB_HEADER));
	ctable  = malloc(sizeof(struct COLOR_TABLE_ENTRY *) * (1 << bpp));
	
	// If any of the memory allocations failed
	if( !bitmap || !fheader || !dheader || !ctable )
	{
		// Clean up any memory allocated
		free(bitmap);
		free(fheader);
		free(dheader);
		free(ctable);
		
		// And just return out
		return NULL;
	}

	// Now we allocate all our color table entries
	for(i = 0; i < (1 << bpp); i++)
	{
		ctable[i] = NULL;
		ctable[i] = malloc(sizeof(struct COLOR_TABLE_ENTRY));
		if(!ctable[i])
		{
			// One of the allocations failed, we need to free all the
			// ones we already allocated and the structures
			for(; i >= 0; i--)
			{
				free(ctable[i]);
			}
			
			free(bitmap);
			free(fheader);
			free(dheader);
			free(ctable);
		
			// And just return out
			return NULL;
		}
		
		// Initalize the entry to black
		ctable[i]->r = 0; ctable[i]->g = 0; ctable[i]->b = 0;
	}
	
	
	// Now let us fill in the headers
	dheader->header_size  = BITMAPCOREHEADER_SIZE;  
	dheader->width        = width;
	dheader->height       = height;
	dheader->color_planes = BITMAPCOREHEADER_COLOR_PLANES;
	dheader->bpp          = bpp;
	
	fheader->magic = BITMAP_MAGIC_NUMBER;
	// We have to calculate the file size
	header_size = BITMAP_FILE_HEADER_SIZE + 
	              dheader->header_size + 
	              ((1 << bpp) * COLOR_TABLE_ENTRY_SIZE);

	// We need to multiply the width by the bpp and round that to the 
	// next multiple of 4 bytes (32 bits) for the row size. 
	if(!((width * bpp) & (31))) // Already a multiple of 32 bits
	{
		row_size = width * bpp;
	}
	else
	{
		// Round up to the next multiple of 32 bits 
		row_size = (((width * bpp) & ~(31)) + 32);
	}          
	fheader->size = header_size + ((row_size / 8) * height);
	
	// Bitmap starts right after our header + color table
	fheader->start = header_size; 
	
	fheader->reserved1 = BITMAP_FILE_HEADER_RESERVED1;
	fheader->reserved2 = BITMAP_FILE_HEADER_RESERVED2;
	
	
	bitmap->file_header = fheader;
	bitmap->dib_header  = dheader;
	bitmap->color_table = ctable;
	
	bitmap->row_width  = row_size / 8;
	bitmap->pixelarray = NULL;
	
	// Finally try and initialize enough memory for our pixel array
	// Rowsize is already a multiple of 4 bytes
	bitmap->pixelarray = malloc((row_size / 8) * height);
	
	if(!bitmap->pixelarray)
	{
		// Failed to allocate enough memory for image, now we have to 
		// free everything again
		free(bitmap->pixelarray);
		
		for(i = 0; i < (1 << bpp); i++)
		{
			free(ctable[i]);
		}
		
		free(bitmap);
		free(fheader);
		free(dheader);
		free(ctable);
	
		// And just return out
		return NULL;
	}
	
	for(i = 0; i < (dheader->height) * (bitmap->row_width); i++)
	{
		bitmap->pixelarray[i] = 0;
	}
	
	// If the allocation succedded, then we are done!
	return bitmap;
}




/* free_bitmap(struct BITMAP *bitmap)
 ** Frees a creaded bitmap from memory
 ****************************************************************/
void free_bitmap(struct BITMAP *bitmap)
{
	int i = 0;
	
	if(bitmap)
	{
		// Failed to allocate enough memory for image, now we have to 
		// free everything again
		free(bitmap->pixelarray);
		
		for(i = 0; i < (1 << bitmap->dib_header->bpp); i++)
		{
			free(bitmap->color_table[i]);
			
			bitmap->color_table[i] = NULL;
		}
		
		
		free(bitmap->file_header); bitmap->file_header = NULL;
		free(bitmap->dib_header);  bitmap->dib_header  = NULL;
		free(bitmap->color_table); bitmap->color_table = NULL;

		

		free(bitmap);
		bitmap = NULL;
	}
}
